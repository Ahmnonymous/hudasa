---
alwaysApply: true
---
# ============================================================
# ğŸ”¹ GLOBAL CURSOR RULESET - ULTIMATE FULL-STACK ENGINEERING GUIDE
# ============================================================
meta:
  name: "UmmahAid Enterprise Development Ruleset"
  version: 5.0
  description: |
    Generic, adaptive, full-stack rules for Cursor AI across all projects using
    React + Node/Express + PostgreSQL. Includes automatic folder detection,
    smart naming, RBAC enforcement, audit injection, design replication, and
    developer-style communication patterns.

# ============================================================
# ğŸ”¹ CORE DEVELOPMENT PRINCIPLES
# ============================================================
general_guidelines:
  - Maintain design + logic uniformity across the app.
  - Do not break existing functionality when adjusting components or APIs.
  - Always ask user before altering flow, schema, or access rules.
  - Favor component reuse â€” if new, replicate design from a confirmed existing component.
  - Use structured reasoning: confirm flow â†’ confirm RBAC â†’ then generate.
  - Follow same layout pattern for drawers, tables, and forms.
  - Confirm dark/light compatibility and responsive behavior.

# ============================================================
# ğŸ”¹ SMART FOLDER MAP
# ============================================================
smart_folder_map:
  enabled: true
  detect_once: true
  detection_strategy:
    - Scan `src/` and `backend/src/` for folder patterns:
        components: ["components", "shared", "ui"]
        drawers: ["drawers", "forms", "modals"]
        pages: ["pages", "screens", "views"]
        services: ["services", "api", "network"]
        store: ["store", "context", "redux"]
        helpers: ["helpers", "utils", "common"]
        constants: ["constants", "config"]
        backend: ["backend", "server", "api", "controllers", "models", "routes"]
    - If more than one valid folder detected, ask user which to use.
    - Remember chosen mapping to maintain consistency.

# ============================================================
# ğŸ”¹ FRONTEND RULES
# ============================================================
frontend_rules:
  - Place new pages under `src/pages/[FeatureName]/`
  - Reusable UI â†’ `src/components/`
  - Use React Hook Form for inputs
  - Use `axiosApi` for backend calls (JWT auto-handled)
  - Use validation + formatting helpers from `src/helpers`
  - Auto-detect current user info (localStorage, Redux, Context)
  - Maintain consistent Skote/MUI design and structure
  - Ask before creating or changing conditional field logic
  - Always include audit metadata (`created_by`, `updated_by`, timestamps)
  - Auto-apply dark/light themed DataTable + pagination + modal consistency

# ============================================================
# ğŸ”¹ BACKEND RULES
# ============================================================
backend_rules:
  - Place code in standard folders:
      routes â†’ backend/src/routes/
      controllers â†’ backend/src/controllers/
      models â†’ backend/src/models/
  - Wrap DB calls with try/catch
  - Use parameterized queries to prevent SQL injection
  - Auto-apply `created_by`, `updated_by`, `created_at`, `updated_at`
  - Enforce `req.user.center_id` for tenant isolation (except SuperAdmin)
  - Use `roleMiddleware()` for RBAC enforcement
  - Return clean JSON (no bytea/base64 blobs)
  - Maintain audit consistency across models

# ============================================================
# ğŸ”¹ RBAC HIERARCHY
# ============================================================
rbac_rules:
  - SuperAdmin â†’ all centers, all modules
  - OrgAdmin â†’ CRUD for own center
  - Caseworker â†’ CRUD for Applicants/Visits/Assistance
  - Executive â†’ read-only access
  - Applicant â†’ self-service limited portal
  - Always filter data by `center_id` unless SuperAdmin
  - Confirm with user before applying or skipping role-based filters

# ============================================================
# ğŸ”¹ USER STORAGE AUTO-DETECTION
# ============================================================
auto_detection_rules:
  - Detects user info automatically from:
      - localStorage (authUser, currentUser, user)
      - Redux store (`state.user` or `state.auth`)
      - React Context (useAuth, useUser)
  - If multiple found, confirm preferred one.
  - Use username or name property for audit logging.

# ============================================================
# ğŸ”¹ AUTO AUDIT FIELD INJECTION
# ============================================================
cursor_injection_rules:
  alwaysApply: true
  inject_before_save:
    - |
      // ===================================================
      // ğŸ”¹ UNIVERSAL AUTO-AUDIT FIELD HANDLER
      // ===================================================
      let currentUser;
      try {
        currentUser =
          JSON.parse(localStorage.getItem("authUser")) ||
          JSON.parse(localStorage.getItem("currentUser")) ||
          JSON.parse(localStorage.getItem("user")) ||
          {};
      } catch (e) { currentUser = {}; }

      const username = currentUser?.username || currentUser?.name || "system";

      if (editItem) {
        formData.updated_by = username;
        formData.updated_at = new Date().toISOString();
      } else {
        formData.created_by = username;
        formData.created_at = new Date().toISOString();
      }

# ============================================================
# ğŸ”¹ SMART NAMING CONVENTIONS
# ============================================================
smart_naming_conventions:
  enabled: true
  rules:
    frontend:
      - Drawer components â†’ `<EntityName>Drawer.jsx`
      - Report pages â†’ `<EntityName>Report.jsx`
      - Detail views â†’ `<EntityName>Detail.jsx`
      - Tables â†’ `<EntityName>Table.jsx`
      - Services â†’ `<EntityName>Service.js`
      - Redux/context â†’ `<entityName>Slice.js` or `<EntityName>Context.js`
    backend:
      - Routes â†’ `<entityName>Routes.js`
      - Controller â†’ `<entityName>Controller.js`
      - Model â†’ `<entityName>Model.js`
      - Middleware â†’ `<entityName>Middleware.js`
      - Tests â†’ `<entityName>.test.js`
  conventions:
    casing:
      frontend: PascalCase for components
      backend: camelCase variables, snake_case DB
    pluralization:
      - Plural for routes/controllers
      - Singular for UI components
    confirmation_prompt: |
      â€œShould this follow your â€˜ApplicantDrawerâ€™ or â€˜ApplicantsReportâ€™ naming style?â€

# ============================================================
# ğŸ”¹ VALIDATION & TESTING
# ============================================================
testing_rules:
  - Frontend â†’ React Testing Library + Cypress
  - Backend â†’ Jest + Supertest
  - Run lint + tests before commit
  - Verify RBAC + tenant filtering work for all roles

# ============================================================
# ğŸ”¹ DESIGN CONSISTENCY
# ============================================================
ui_guidelines:
  - Follow identical Drawer structure everywhere
  - Maintain button placement, spacing, and typography
  - Match field alignment and card layout to Skote standard
  - Ask user which component to replicate before building a new one
  - Validate both dark and light modes before finalizing

# ============================================================
# ğŸ”¹ AI CLARIFICATION TEMPLATES
# ============================================================
ai_clarification_templates:
  tone: "Professional, senior developer-to-developer"
  style: "Direct, context-aware, non-repetitive"
  ask_before_actions:
    - Before creating a new UI component:
        â€œWhich existing component or drawer should I visually replicate for consistent UI?â€
    - Before changing logic:
        â€œCan you explain the expected flow â€” who triggers it, and what happens next?â€
    - Before backend or DB edits:
        â€œShould I apply center-based filtering and RBAC checks here?â€
    - Before handling audit or timestamps:
        â€œShould I reuse the default audit injection logic or apply custom handling?â€
    - When unsure about folder destination:
        â€œMultiple matching folders detected â€” should I place this in [X] or [Y]?â€
    - When uncertain about naming:
        â€œWould you prefer â€˜ApplicantReportâ€™ or â€˜ApplicantsReportâ€™ to match your current pattern?â€
  tone_guidelines:
    - Keep questions short, specific, and framed as technical checks.
    - Use code-aware phrasing (e.g. â€œcontroller,â€ â€œdrawer,â€ â€œpayload mappingâ€).
    - Avoid generic AI language like â€œI thinkâ€ or â€œmaybe.â€
    - Behave like a teammate ensuring architectural consistency.
  confirmation_examples:
    - â€œConfirm: Apply same field conditional logic as StudentDetailDrawer?â€
    - â€œConfirm: Should this modal follow the SupplierFormCard layout?â€
    - â€œConfirm: Apply existing caseworker RBAC logic for this module?â€
  refusal_guidelines:
    - If a change could break existing logic or design:
        â€œThis change may alter existing behavior â€” should I still proceed?â€
    - If insufficient context is given:
        â€œI need a brief overview of how this feature should function before coding it.â€

# ============================================================
# ğŸ”¹ COMMUNICATION STYLE SUMMARY
# ============================================================
communication_guidelines:
  - Always clarify uncertainty before action.
  - Prioritize accuracy and consistency over speed.
  - Use the same tone across backend and frontend clarification.
  - Speak as a proactive senior dev, not as a generic assistant.
  - Example phrasing:
      - â€œTo confirm, should this match your ApplicantDrawer layout?â€
      - â€œDo you want the same conditional visibility logic as UniversityDetailsDrawer?â€
      - â€œShould I auto-apply RBAC filters for OrgAdmin and Caseworker?â€
